<h3> Tutorial example layoutDesign </h3>

<p>
Files
<ul>
<li> <a href="layoutDesignOriginal.py"> <i> layoutDesignOriginal.py </i> </a>
<li> <a href="layoutDesignAltered.py"> <i> layoutDesignAltered.py </i> </a>
</ul>

In tutorial example LayoutDesign the following layout design facilities are explained:

<ol>
<li> The application.designMode flag
<li> FixedSize views
<li> Explicit view keys
</ol>

If flag application.designMode is set to True, FillerViews are made visible.
This makes it easier to design the layout of a window.
In addition, any window can be constructed with parameter fixedSize set to True.
In this case, if application.designMode is set to False, the window can not be resized.
However, if application.designMode is set to True, the window can be resized to give it the proper layout once and for all.

<p>
During design it often happens that views are added or removed.
The layout of each view is persisted under an implicit key.
Implicit keys are generated in sequence order of view creation.
Adding or deleting a view during development will change the view creation sequence and hence the implicit keys.
This will mess up the layout of your application.
If you want layout persistence to work during development, you can assign explicit keys to the views that have layout state.
Currently MainView, ModalView, ModelessView, ListView and SplitView have layout state.

<p>
To illustrate the benefits of explicit keys example layoutDesignAltered lacks two ListViews that were present in layoutDesignOriginal.
Running these two examples alternately shows that other views are not messed up by adding or removing these ListViews.

<p>
Remark: If you don't want to spend a lot of thought on a globally unique key,
you can e.g. use date and time or the GUID's that can be generated by some development environments.
