<h3> Tutorial example CalculatorPush </h3>

<p>
Files
<ul>
<a href="calculatorPush.py"> calculatorPush.py </a>
</ul>

In tutorial example CalculatorPush information is written directly into resultNode.
<ol>
<li>As one of the +, -, * or / buttons is pressed, the appropriate action callback is called.
<li>This callback then writes the computation result into resultNode.
</ol>

<p>
Writing information directly into Nodes by calling aNode.follow in anotherNode.action is called the Push pattern.
Since all Nodes have an action, the Push pattern can be applied pervasively, completely avoiding Node.dependsOn.
This approach has the advantage of being familiar ground for many programmers.
But it lacks the advantages typical for the Observer pattern, that underlies the Pull pattern.

<p>
Still there are situations were part of the propagation through the Node network is better done by Push than by Pull.
One example is the existence of dynamically instantiated subnets:

<ol>
<li> Internally the subnets should preferably use the Pull pattern.
<li> But interlinking them is best done by the Push pattern.
</ol>

Although the metaphore is skewed, consider the situation in our nervous system:
<ol>
<li> Most of the distance, signals travel electrically through fixed wiring, called axons.
<li> At the boundary between two separately grown and later connected nerve cels, a synapse enables propagation.
</ol>

<p>
To help you cross the bridge between procedural habits and functional Eden:
Use the Pull pattern whereever possible, especially if you're new to Eden.

<p>
<b>Warning:</b> If you occasionaly need the Push pattern, use Node.follow, <b>not</b> Node.change.